Session hijacking via MITM
=====

Level: Simple.

What is this attack?
-----

A session hijack is where you have a session - an ongoing HTTP conversation - with a website, and an attacker gains access to this session, communicating with the site as if he were you. This may kick you off, or you may be unaware that he is also using your session. The session may or may not be authenticated, but it is likely that it is if any sensitive information is involved. This means that the attacker can do what ever you can on the site in question at the time of the hijack - change your password, read your mail, transfer money, whatever.

A man in the middle (MITM) attack is where the attacker can intercept the network communications between your browser and the server, and read, block or modify it. There are many places this can be done, from malware on your PC to unsecured or compromised wireless networks to unscrupulous ISPs and governments. These events are outside the control of the web app developer or the user.


Exercise 1: Find out how your app works, using Fiddler
-----

First, a general discussion of what a session is. HTTP is stateless, meaning that each GET/POST/whatever and its response between a client and a server is independent of the next. Clearly this isn't how it looks to the user, what we conceptualize is a session - an ongoing conversation between you and the site. So some extra plumbing is required, and at a high level of abstraction, this involves there being some additional data being passed back and forth saying 'this HTTP request is part of a specific conversation'. There are many architectures for doing this, and the samples in this course form a small subset of those. The session architecture also encompasses concerns about authentication and how the data is persisted between requests on the client and/or server sides, but for now we're going to ignore that and just worry about how that data is passed.

*Dev-specific*
The first part of the exercise is to look at the architecture/design docs (if there are any - there aren't for these sample apps) and the code, to see how it is supposed to work. Maybe you wrote the code, so you think you know how it works, and you know it basically works, right?

The next part of the exercise is to observe the web traffic the app generates, with Fiddler. Start Fiddler and drive the sample app through a cycle of logging on and submitting a post. Look at all the requests and figure out exactly what information is being passed to maintain the session, and how - what part of the request/response is it? 

In the MEAN_stack sample, its a JWT, passed as the body of the response of the post to /api/sessions, and in the X-Auth request header of subsequent requests. A JWT is a JSON web token, which is an encoded signed bit of data, with a payload generated by the app - in this case, just the username. Copy the string out of Fiddler and take look, using http://jwt.io/. Not that it's not encrypted, and it doesn't have anything identifying IP addresses or anything like that. It's just a bearer token - if you've got the token you've got the session. The signature simply tells the server that it created this token and it hasn't been tammpered with. 

We know that the MEAN_stack sample is an AngularJS app, and a glance at the (unminified) app.js using Chrome dev tools confirms that. This JS source code IS PUBLIC - any user can see it, and the attacker can see that the app gets the token, uses it to get a user from the users API and passes it to the server when submitting a new post. So now have all the information we need to  hijack a session in this sample.


Exercise 2: Run the hijack by hand, using Fiddler
-----

In fact, you've already done the first part of the attack. Fiddler is an HTTP proxy, which is to say a (benign) man in the middle. It's reading the HTTP traffic between client and server. If it was not benign, 


*dev-specific, very optional*
Exercise 3: Automate the hijack
-----

Fiddler allows you to script behaviour at various points in the proxying cycle. So you can make it do stuff prior to forwarding requests or responses. The Attacker sample has an API to which you can send JSON, and it publishes what it receives via websockets. So you probably have enough plumbing to automatically hijack sessions, if you want to try. Let's say we want any user to involuntarily post an offensive message when he logs in. Kind of cool, but it's doesn't tell you much you didn't already know, and I'll leave that as an exercise. 


Exercise 4: Use OWASP ZAP to find unprotected session IDs
-----


*dev-specific*
Exercise 5: Mitigate by using HTTPS throughout
-----

HTTPS throughout - HSTS
Secure cookies


Other mitigations
-----
Expiry policies
Reauthentication
Separating session from auth, changing sessionID after auth


